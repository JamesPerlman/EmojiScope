{"version":3,"sources":["store/useTypedSelector.ts","store/emojiList/selectors.ts","components/UI/atoms/EmojiView.tsx","components/UI/molecules/EmojiLink.tsx","constants/animation.ts","hooks/useInterval.ts","hooks/useOnChange.ts","store/emojiList/actionTypes.ts","hooks/usePrevious.ts","hooks/useDragDisplacement.ts","hooks/useMousePosition.ts","contexts/MousePositionContext.tsx","components/UI/organisms/ReactiveGridItem.tsx","hooks/useMousePositionContext.ts","components/UI/organisms/ReactiveGrid.tsx","components/pages/EmojiBrowserPage.tsx","store/emojiList/actionCreators.ts","App.tsx","store/categoryList/actionTypes.ts","reportWebVitals.ts","store/categoryList/reducer.ts","store/emojiList/reducer.ts","store/rootReducer.ts","models/Category.ts","models/Emoji.ts","config.ts","api/client.ts","api/methods/emojis.ts","api/api.ts","store/emojiList/sagas.ts","store/rootSaga.ts","store/index.ts","index.tsx","libs/ShiftedGrid/types/GridDirection.ts","utils/BoundingRectUtil.ts","utils/CodecUtil.ts","utils/EnvUtil.ts","utils/MathUtil.ts","libs/ShiftedGrid/constants/index.ts","libs/ShiftedGrid/types/index.ts","types/ItemStyleEffect/index.ts","libs/ShiftedGrid/index.ts","libs/ShiftedGrid/types/2DTypes.ts","libs/ShiftedGrid/types/GridQuadrant.ts","libs/ShiftedGrid/types/RingCorner.ts","types/ItemStyleEffect/EdgeFadeEffect.ts","types/ItemStyleEffect/MagnificationEffect.ts","libs/ShiftedGrid/utils/CartesianUtil.ts","libs/ShiftedGrid/utils/GridRayUtil.ts","libs/ShiftedGrid/utils/LineUtil.ts","libs/ShiftedGrid/utils/QuadrantUtil.ts","libs/ShiftedGrid/utils/RingUtil.ts","libs/ShiftedGrid/utils/GridUtil.ts","libs/index.ts"],"names":["useTypedSelector","useSelector","selectEmojis","state","emojis","items","EmojiViewElement","props","char","itemSize","style","dynamicStyle","useMemo","width","height","fontSize","Math","min","className","EmojiView","React","memo","EmojiLinkElement","emoji","to","pathname","character","detail","EmojiLink","AnimationConstants","defaultOptions","autoStart","EmojiListActionTypes","useOnChange","value","from","callback","deps","previousValue","ref","useRef","useEffect","current","usePrevious","callbackWithDependencies","useCallback","useDragDisplacement","zero2D","x","y","options","isDragging","mousePoint","displacementRef","prevEventTime","Date","now","mouseSpeed","useState","displacementState","setDisplacementState","isDecelerating","setIsDecelerating","handleMouseDown","event","preventDefault","clientX","clientY","createHandleMouseDown","handleMouseMove","prevMousePoint","curMousePoint","subtract2D","dx","dy","dt","displacementDifference","currentDisplacement","add2D","createHandleMouseMove","handleMouseUp","createHandleMouseUp","window","addEventListener","removeEventListener","lastDecelFrameTime","delay","callbackRef","delayRef","intervalRef","isPaused","performCurrentCallback","undefined","pause","clearInterval","play","setInterval","unmount","useInterval","vx","vy","newVelocity","damping","px","py","newDisplacement","sqrt","pow","pauseDecelAnimation","console","log","startDecelAnimation","useMousePosition","origin2D","coords","setCoords","mouseMoveEventListener","createMouseMoveEventListener","MousePositionContext","createContext","mousePosition","MousePositionContextProvider","children","transformMousePosition","Provider","Consumer","ReactiveGridItemElement","grid","index","effects","gridCenter","gridOffset","useContext","itemPosition","gridCoordToScreenPoint","GridUtil","indexToCoord","reactiveStyles","reduce","prevStyle","curEffect","getStyle","centerPosition","position","overflow","unitSize","ReactiveGridItem","ReactiveGrid","typedMemo","itemRadius","itemSpacing","magnification","effectRadius","renderItem","dragDisplacement","useMomentum","setGridCenter","BoundingRectUtil","emptyBoundingRect","windowedBounds","setGridBounds","handleResize","info","bounds","getCenter","containerTopLeft","left","top","halfItemSizeOffset","offsetCenter","createShiftedGrid","scrollOffset","scaledScrollOffset","normalize2D","gridCoordsInWindowedScrollArea","scaledWindowedBounds","getNormalized","ceilOfWidth","ceil","ceilOfHeight","ceilOfWidthPlusOne","ceilOfHeightPlusOne","gridCoords","cartPoint","gridCoord","CartesianUtil","cartToGrid","push","adjustMousePosition","inputMousePosition","windowedTopLeftPosition","magnifyEffect","createMagnificationEffect","fadeDropOffDistance","SQRT1_2","createEdgeFadeEffect","onResize","measureRef","map","coordToIndex","item","EmojiBrowserPageElement","gridSize","setGridSize","sideLength","display","alignItems","justifyContent","EmojiBrowserPage","EmojiListActionCreator","type","BeginFetchRequest","data","FetchRequestDidSucceed","payload","error","FetchRequestDidFail","App","CategoryListActionTypes","dispatch","useDispatch","exact","path","component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","INITIAL_STATE","loading","rootReducer","combineReducers","categories","action","CategoryModel","t","slug","subCategories","EmojiModel","unicodeName","codePoint","group","subGroup","Emoji","config","api","baseURL","accessKey","EnvUtil","openEmojiAPIKey","client","axios","create","timeout","params","access_key","a","get","CodecUtil","decode","listAll","fetchEmojiListSaga","emojiListSaga","call","put","all","takeLatest","rootSaga","fork","sagaMiddleware","createSagaMiddleware","middleware","applyMiddleware","logger","store","createStore","run","ReactDOM","render","document","getElementById","GridDirection","CartesianSlope","NX","PX","NXNY","PXPY","PXNY","NXPY","DirectionFromCenterToCorner","rect","right","bottom","getScaled","scale","center","Error","Promise","resolve","reject","pipe","fold","process","MathUtil","SQRT3","ISQRT3","modulo","b","GridConstants","EPSILON","diagonallyAdjacentNodeDistance","yAxisCompression","s","GridQuadrant","CornerDirectionForQuadrant","PY","NY","IntersectorDirectionForQuadrant","Object","values","first","second","third","fourth","fifth","sixth","startFadeOutDistance","distToCenter","opacity","getDistance","max","createScaleFunction","r","PI","pScale","p","abs","cos","fScale","effectPosition","maximumScale","getTranslation","c","r1a","bsincr","sin","pDisp","createDisplacementFunction","getScale","transform","gridToCart","cx","cy","ry","round","k","gx","gy","floor","createGridRay","startCoord","direction","p1x","p1y","contains","p2x","p2y","asCartLine","slope","this","intercept","getGridQuadrant","d","getRingCornerCoord","origin","ringIndex","ringCorner","cornerPoint","traverse","xComponentAdjustment","fromPointY","traversalMagnitude","defaultStretchXY","offsetXY","stretchXY","ox","oy","sx","sy","spaceSize","coord","screenPointToGridCoord","m","getDistanceBetween","coordA","coordB","cartPointA","cartPointB","unreliableDistanceBetween","gridCoordA","gridCoordB","traversalDirections","nodeIndex","getRingIndex","nodeSubIndex","getFirstNodeIndexInRing","leadingCorner","getLeadingRingCorner","cornerSubIndex","getRingCornerSubIndex","cornerRay5Origin","targetCoord","targetQuadrant","targetIntersectorRay","leadingCornerDirection","cornerRayStartCoord","cornerRay","intersectionPoint","line1","line2","slopeDifference","getLineIntersection","leadingRingCornerCoord","targetRingIndex","leadingRingCorner","getRingCornerOfCornerCoord","areCoordsColinear","isCoordBetween","xMin","xMax","yMin","yMax"],"mappings":"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","file":"static/js/main.63dcf1e6.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useSelector } from 'react-redux';\nimport { AppState } from './rootReducer';\n\nexport const useTypedSelector: TypedUseSelectorHook<AppState> = useSelector;\n","import { AppState } from '../rootReducer';\nimport { useTypedSelector } from '../useTypedSelector';\n\nconst selectEmojis = (state: AppState) => state.emojis.items;\n\nexport const useSelectEmojis = () => useTypedSelector(selectEmojis);\n","import React, { useMemo } from 'react';\nimport 'tailwindcss/tailwind.css';\nimport { Size2D } from '../../../libs';\nimport './EmojiView.css';\ninterface EmojiViewProps {\n  char: string;\n  style?: React.CSSProperties;\n  itemSize: Size2D;\n}\n\nconst EmojiViewElement: React.FC<EmojiViewProps> = (props) => {\n  const { char, itemSize, style } = props;\n\n  const dynamicStyle = useMemo(\n    () => ({\n      width: `${itemSize.width - 5}px`,\n      height: `${itemSize.height - 5}px`,\n      fontSize: Math.min(itemSize.width, itemSize.height) - 10,\n    }),\n    [itemSize],\n  );\n\n  return (\n    <div className=\"emoji-view-container\" style={{ ...dynamicStyle, ...(style ?? {}) }}>\n      {char}\n    </div>\n  );\n};\n\nexport const EmojiView = React.memo(EmojiViewElement);\n","import React from 'react';\nimport { Link } from 'react-router-dom';\nimport { Size2D } from '../../../libs';\nimport { Emoji } from '../../../models';\nimport { EmojiView } from '../atoms';\n\ninterface EmojiLinkProps {\n  emoji: Emoji;\n  itemSize: Size2D;\n}\n\nconst EmojiLinkElement = (props: EmojiLinkProps) => {\n  const { emoji, itemSize } = props;\n  return (\n    <Link\n      to={{\n        pathname: `/${emoji.character}`,\n        state: { detail: true },\n      }}>\n      <EmojiView char={emoji.character} itemSize={itemSize} />\n    </Link>\n  );\n};\n\nexport const EmojiLink = React.memo(EmojiLinkElement);\n","export const AnimationConstants = {\n  millisecondsFor30fps: 1.0 / 30.0,\n  millisecondsFor60fps: 1.0 / 60.0,\n};\n","// inspired by and adapted from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n\nimport { useCallback, useEffect, useRef } from 'react';\nimport { setInterval } from 'timers';\n\n// Define some exported convenience types here\n\nexport type UserIntervalHookCallback = () => void;\n\nexport type UseIntervalPlayFunction = () => void;\n\nexport type UseIntervalPauseFunction = () => void;\n\nexport type UseIntervalHookControls = [UseIntervalPlayFunction, UseIntervalPauseFunction];\n\nexport type UseIntervalHookOptions = {\n  autoStart: boolean; // automaticall start interval when hook is executed\n};\n\n// Define some default convenience consts here\n\nconst defaultOptions = { autoStart: false };\n\n/**\n * @name useInterval\n * @description - A hook that uses setInterval under the hood to run a callback on a timer\n * @param {function} callback - The callback to run\n * @param {number} delay - The millisecond delay between each invocation of callback\n * @param {UseIntervalHookOptions} options - Automatically start the interval when useInterval(...) is called\n *\n * @return {UseIntervalHookControls} - An array of [play, pause].  These are guaranteed to remain the same throughout the hook's life.\n */\nexport function useInterval(\n  callback: UserIntervalHookCallback,\n  delay: number,\n  options: UseIntervalHookOptions = defaultOptions,\n) {\n  const callbackRef = useRef<UserIntervalHookCallback>();\n  const delayRef = useRef<number>(delay);\n  const intervalRef = useRef<number>();\n  const isPaused = useRef<boolean>(!options.autoStart);\n\n  // This function is meant to be used within setInterval, and it always executes the current callbackRef\n  function performCurrentCallback() {\n    if (callbackRef.current !== undefined) {\n      callbackRef.current();\n    }\n  }\n\n  /**\n   * @name - pause\n   * @description - Pause execution of the callback via clearInterval\n   */\n  const pause = useCallback(() => {\n    // if we are already paused, we don't need to do anything here.\n    if (isPaused.current) {\n      // early return stops execution\n      return;\n    }\n\n    // if we've made it here, it means we aren't paused\n    // so let's indicate that we are paused by setting isPaused = true\n    isPaused.current = true;\n\n    // pause means that we are going to remove the current interval completely.\n    if (intervalRef.current) {\n      window.clearInterval(intervalRef.current);\n      intervalRef.current = undefined;\n    }\n  }, []);\n\n  /**\n   * @name - play\n   * @description - Begins execution of the callback via setInterval\n   */\n\n  const play = useCallback(() => {\n    // we only want to execute the play() function if we are paused\n    if (!isPaused.current) {\n      // if we are not paused, it means we are already playing, therefore we should return early to prevent any unexpected behavior\n      return;\n    }\n\n    // if we made it to this point it means we are paused, and we can start playing now\n    // so first, let's set isPaused = false\n    isPaused.current = false;\n\n    // if we had a previous intervalRef, we need to clear it before setting a new one.\n    // theoretically this should not ever happen, but we need to make sure.\n    if (intervalRef.current !== undefined) {\n      window.clearInterval(intervalRef.current);\n    }\n\n    // now, let's use setInterval to start executing the callback\n    intervalRef.current = window.setInterval(performCurrentCallback, delayRef.current);\n  }, []);\n\n  // cleanup function for hook destruction // unmounting\n  const unmount = () => {\n    if (intervalRef.current !== undefined) {\n      window.clearInterval(intervalRef.current);\n    }\n  };\n\n  // keep callbackRef up-to-date\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  // keep delayRef up-to-date\n  useEffect(() => {\n    delayRef.current = delay;\n\n    // since delay has changed, we need to clear the current interval and set a new one\n    // but only also if we are not paused\n    if (isPaused.current === false && intervalRef.current !== undefined) {\n      window.clearInterval(intervalRef.current);\n      intervalRef.current = window.setInterval(performCurrentCallback, delayRef.current);\n    }\n  }, [delay]);\n\n  // one-time-only effect (for handling autoStart case)\n  useEffect(() => {\n    // if we don't want to autoStart, then we return early and do nothing here\n    if (!options.autoStart) {\n      return;\n    }\n\n    if (options.autoStart) {\n      intervalRef.current = window.setInterval(performCurrentCallback, delayRef.current);\n    }\n\n    // cleanup function\n    return unmount;\n  }, []);\n\n  return [play, pause];\n}\n","import React, { useCallback, useEffect } from 'react';\nimport { usePrevious } from './usePrevious';\n\n/**\n * @name useOnChange\n * @description - Executes a callback when the value of `value` changes from `from` to `to`\n * @template T - The type of `value`\n * @template U - The type of `callback`\n * @param {T} value - The value to compare\n * @param {T} from - The previous value of `value` to compare against\n * @param {T} to - The current value of `value` to compare against\n * @param {U} callback - The callback to execute\n */\n\n// this `U extends Parameters<typeof useCallback>[0]` is an attempt to make this future-proof.  see the comment above `useCallback`.\nexport const useOnChange = <T, U extends Parameters<typeof useCallback>[0]>(\n  value: T,\n  from: T,\n  to: T,\n  callback: U,\n  deps: React.DependencyList,\n) => {\n  const previousValue = usePrevious(value);\n\n  const callbackWithDependencies = useCallback(callback, deps);\n\n  useEffect(() => {\n    if (value === to && previousValue === from) {\n      callbackWithDependencies();\n    }\n  }, [value, previousValue, from, to]);\n};\n","import { Emoji } from '../../models';\nimport { EmojiListActionError } from './types';\n\n// Action Types Enum\nexport enum EmojiListActionTypes {\n  BeginFetchRequest = 'EmojiListBeginFetchRequest',\n  FetchRequestDidSucceed = 'EmojiListFetchRequestDidSucceed',\n  FetchRequestDidFail = 'EmojiListFetchRequestDidFail',\n}\n\n// Action Object Types\nexport type EmojiListRequestBegin = {\n  type: EmojiListActionTypes.BeginFetchRequest;\n};\n\nexport type EmojiListRequestSucceed = {\n  type: EmojiListActionTypes.FetchRequestDidSucceed;\n  payload: Emoji[];\n};\n\nexport type EmojiListRequestFail = {\n  type: EmojiListActionTypes.FetchRequestDidFail;\n  payload: EmojiListActionError;\n};\n\n// Action types Union\nexport type EmojiListActions =\n  | EmojiListRequestBegin\n  | EmojiListRequestSucceed\n  | EmojiListRequestFail;\n","import { useEffect, useRef } from 'react';\n\nexport function usePrevious<T>(value: T) {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n","// Inspired by https://valtism.com/src/use-drag-scroll.html\n\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { AnimationConstants } from '../constants';\nimport { add2D, Point2D, subtract2D, Velocity2D } from '../libs';\nimport { useInterval } from './useInterval';\nimport { useOnChange } from './useOnChange';\n\nexport type DragDisplacementHookOptions = {\n  useMomentum: boolean;\n  damping: number; // between 0 and 1\n};\n\n/**\n * @description This is a hook for determining when a user drags the mouse\n * @return displacement of mouse drag\n */\nexport const useDragDisplacement = (function () {\n  const zero2D: Point2D = { x: 0, y: 0 };\n\n  /*\n    Optimization technique: defining function factories outside of the actual hook allows us to create the function we need once (within the useEffect that runs only once)\n    Instead of defining these functions inside the body of the hook, in which case they would be defined every time the hook runs (aka at least every time the mouse moves)\n    ...which seems like a completely unnecessary waste of performance\n  */\n  function createHandleMouseDown(\n    isDragging: React.MutableRefObject<boolean>,\n    mousePoint: React.MutableRefObject<Point2D>,\n    prevEventTime: React.MutableRefObject<number>,\n    setIsDecelerating: React.Dispatch<React.SetStateAction<boolean>>,\n  ) {\n    return (event: MouseEvent) => {\n      // prevent default behavior of this event\n      event.preventDefault();\n\n      // stop deceleration animation\n      setIsDecelerating(false);\n\n      // set isDragging = true (start dragging)\n      isDragging.current = true;\n\n      // update mousePoint at start of drag\n      mousePoint.current = { x: event.clientX, y: event.clientY };\n\n      // update prevEventTime\n      prevEventTime.current = Date.now();\n    };\n  }\n\n  function createHandleMouseMove(\n    displacementRef: React.MutableRefObject<Point2D>,\n    isDragging: React.MutableRefObject<boolean>,\n    mousePoint: React.MutableRefObject<Point2D>,\n    prevEventTime: React.MutableRefObject<number>,\n    mouseSpeed: React.MutableRefObject<Velocity2D>,\n    setDisplacementState: React.Dispatch<React.SetStateAction<Point2D>>,\n  ) {\n    return (event: MouseEvent) => {\n      // If we're not currently dragging, we don't want to execute any code here.\n      if (!isDragging.current) {\n        return;\n      }\n      // prevent event default\n      event.preventDefault();\n\n      // Save previous position\n      const prevMousePoint = mousePoint.current;\n\n      // Get a reference to the current mouse x and y\n      const curMousePoint: Point2D = { x: event.clientX, y: event.clientY };\n\n      // Now we can get the difference between the current and previous mouse positions\n      const { x: dx, y: dy } = subtract2D(curMousePoint, prevMousePoint);\n\n      // We also need to get the difference in time since the last mouse event (in milliseconds)\n      const dt = 0.001 * (Date.now() - prevEventTime.current);\n\n      // Now we can calculate the speed of the last mouse move\n      mouseSpeed.current = {\n        x: dx / dt,\n        y: dy / dt,\n      };\n\n      // Update current mousePoint based on this event\n      mousePoint.current = curMousePoint;\n\n      // Calculate displacement difference\n      const displacementDifference: Point2D = subtract2D(curMousePoint, prevMousePoint);\n\n      // Add displacementDifference to displacementRef.current to get new displacement\n      const currentDisplacement: Point2D = add2D(displacementRef.current, displacementDifference);\n\n      // Update displacement (using ref value)\n      displacementRef.current = currentDisplacement;\n\n      // Update displacement (using state setter)\n      setDisplacementState(displacementRef.current);\n\n      // Update prevEventTime\n      prevEventTime.current = Date.now();\n    };\n  }\n\n  function createHandleMouseUp(\n    isDragging: React.MutableRefObject<boolean>,\n    mousePoint: React.MutableRefObject<Point2D>,\n    prevEventTime: React.MutableRefObject<number>,\n    setIsDecelerating: React.Dispatch<React.SetStateAction<boolean>>,\n  ) {\n    return (event: MouseEvent) => {\n      // prevent event default\n      event.preventDefault();\n\n      // set isDragging = false (stopDragging)\n      isDragging.current = false;\n\n      /*\n        The theory:\n\n        When mouse goes up, we need to know what the dragging velocity is.\n        Once we have the dragging velocity, we can start a process that decreases the velocity over time\n        This will simulate deceleration, aka the \"drag momentum effect\"\n      */\n\n      // let's get the cursor velocity\n      const curMousePoint: Point2D = {\n        x: event.clientX,\n        y: event.clientY,\n      };\n\n      // Now we trigger the deceleration animation by setting isDecelerating = true\n      setIsDecelerating(true);\n\n      // Update current mousePoint based on this event\n      mousePoint.current = curMousePoint;\n\n      // Update prevEventTime\n      prevEventTime.current = Date.now();\n    };\n  }\n\n  /*\n    RETURN THE ACTUAL HOOK FUNCTION HERE!\n  */\n  return (options: DragDisplacementHookOptions): Point2D => {\n    // setup some ref vars\n    const isDragging = useRef<boolean>(false);\n    const mousePoint = useRef<Point2D>(zero2D);\n    const displacementRef = useRef<Point2D>(zero2D);\n    const prevEventTime = useRef<number>(Date.now());\n    const mouseSpeed = useRef<Velocity2D>(zero2D);\n\n    // setup some state vars\n    const [displacementState, setDisplacementState] = useState<Point2D>(zero2D);\n    const [isDecelerating, setIsDecelerating] = useState<boolean>(false);\n\n    // Main useEffect for this hook, sets up all the mouse event listeners\n    useEffect(() => {\n      // Create handleMouse optimized functions using our parent-scope function creators\n      const handleMouseDown = createHandleMouseDown(\n        isDragging,\n        mousePoint,\n        prevEventTime,\n        setIsDecelerating,\n      );\n\n      const handleMouseMove = createHandleMouseMove(\n        displacementRef,\n        isDragging,\n        mousePoint,\n        prevEventTime,\n        mouseSpeed,\n        setDisplacementState,\n      );\n\n      const handleMouseUp = createHandleMouseUp(\n        isDragging,\n        mousePoint,\n        prevEventTime,\n        setIsDecelerating,\n      );\n\n      // Add listeners for mouse events\n      window.addEventListener('mousedown', handleMouseDown);\n      window.addEventListener('mousemove', handleMouseMove);\n      window.addEventListener('mouseup', handleMouseUp);\n\n      // return a function that gets called when the component using this hook gets unmounted\n      return () => {\n        // When component unmounts, we want to remove the mouse event listeners we added earlier.\n        window.removeEventListener('mousedown', handleMouseDown);\n        window.removeEventListener('mousemove', handleMouseUp);\n        window.removeEventListener('mouseup', handleMouseUp);\n      };\n    }, []);\n\n    /* MOMENTUM EFFECTS */\n\n    const lastDecelFrameTime = useRef<number>(0);\n\n    const decelDragCallback = useCallback(() => {\n      // we need to get dt, aka the time that has elapsed since startDecelAnimation() was called\n      // dt is in seconds\n      const dt = 0.001 * (Date.now() - lastDecelFrameTime.current);\n\n      // Now we just do some physics\n      // velocity += accel * dt\n\n      const { x: vx, y: vy } = mouseSpeed.current;\n\n      // Just use damping to decrease velocity\n      const newVelocity: Velocity2D = {\n        x: vx * options.damping,\n        y: vy * options.damping,\n      };\n\n      // position += velocity * dt\n      const { x: px, y: py } = displacementRef.current;\n      const newDisplacement: Point2D = {\n        x: px + newVelocity.x * dt,\n        y: py + newVelocity.y * dt,\n      };\n\n      mouseSpeed.current = newVelocity;\n      displacementRef.current = newDisplacement;\n\n      setDisplacementState(newDisplacement);\n\n      // at some point if velocity is close enough to zero, we have to pauseDecelAnimation\n      const newVelocityMagnitude = Math.sqrt(\n        Math.pow(newVelocity.x, 2) + Math.pow(newVelocity.y, 2),\n      );\n      if (newVelocityMagnitude < 1) {\n        pauseDecelAnimation();\n        console.log('stop decelerating');\n      }\n      lastDecelFrameTime.current = Date.now();\n      console.log('decelerating');\n    }, [options.damping]);\n\n    const [startDecelAnimation, pauseDecelAnimation] = useInterval(\n      decelDragCallback,\n      AnimationConstants.millisecondsFor30fps,\n    );\n\n    // this is where the magical momentum effects happen\n    // when isDecelerating changes from false to true, we begin animating and decelerating\n    useOnChange(\n      isDecelerating,\n      false,\n      true,\n      () => {\n        lastDecelFrameTime.current = Date.now();\n        startDecelAnimation();\n      },\n      [],\n    );\n\n    // when isDecelerating changes from true to false, we stop animating and decelerating\n\n    useOnChange(\n      isDecelerating,\n      true,\n      false,\n      () => {\n        pauseDecelAnimation();\n      },\n      [],\n    );\n\n    return {\n      x: displacementState.x,\n      y: displacementState.y,\n    };\n  };\n})();\n","import React, { useEffect, useState } from 'react';\nimport { origin2D, Point2D } from '../libs';\n\nexport const useMousePosition = (function () {\n  function createMouseMoveEventListener(\n    setCoords: React.Dispatch<React.SetStateAction<Point2D>>,\n  ): (event: MouseEvent) => void {\n    return function (event: MouseEvent) {\n      setCoords({\n        x: event.clientX,\n        y: event.clientY,\n      });\n    };\n  }\n\n  return function (): Point2D {\n    const [coords, setCoords] = useState<Point2D>(origin2D);\n\n    useEffect(() => {\n      const mouseMoveEventListener = createMouseMoveEventListener(setCoords);\n\n      window.addEventListener('mousemove', mouseMoveEventListener);\n\n      return () => window.removeEventListener('mousemove', mouseMoveEventListener);\n    }, []);\n\n    return coords;\n  };\n})();\n","import React from 'react';\nimport { useMousePosition } from '../hooks';\nimport { origin2D, Point2D } from '../libs';\n\nexport type MousePositionContextValueType = {\n  mousePosition: Point2D;\n};\n\nexport const MousePositionContext = React.createContext<MousePositionContextValueType>({\n  mousePosition: origin2D,\n});\n\nexport type MousePositionContextProviderProps = React.PropsWithChildren<{\n  transformMousePosition?: (inputMousePosition: Point2D) => Point2D\n}>;\n\nexport const MousePositionContextProvider: React.FC<MousePositionContextProviderProps> = (\n  props,\n) => {\n  const { children, transformMousePosition } = props;\n\n  let mousePosition = useMousePosition();\n\n  if (transformMousePosition !== undefined) {\n    mousePosition = transformMousePosition(mousePosition);\n  }\n\n  return (\n    <MousePositionContext.Provider value={{ mousePosition }}>\n      {children}\n    </MousePositionContext.Provider>\n  );\n};\n\nexport type MousePositionContextConsumerProps = React.PropsWithChildren<{}>;\n\nexport const MousePositionContextConsumer = MousePositionContext.Consumer;\n","import React, { useMemo } from 'react';\nimport { useMousePositionContext } from '../../../hooks';\nimport { add2D, GridUtil, Point2D, ShiftedGrid } from '../../../libs';\nimport { ItemStyleEffect } from '../../../types';\n\ntype ReactiveGridItemProps = React.PropsWithChildren<{\n  grid: ShiftedGrid;\n  index: number;\n  effects?: ItemStyleEffect[];\n  gridCenter: Point2D;\n  gridOffset: Point2D;\n}>;\n\nconst ReactiveGridItemElement: React.FC<ReactiveGridItemProps> = (props) => {\n  const { children, grid, index, effects, gridCenter, gridOffset } = props;\n\n  // TODO: a way of turning on & off effects\n  // Grabbing mousePosition from a context is SO MUCH FASTER than using useMousePosition here!\n  const mousePosition = useMousePositionContext().mousePosition;\n\n  const itemPosition = useMemo(\n    () => add2D(gridOffset, grid.gridCoordToScreenPoint(GridUtil.indexToCoord(index))),\n    [grid, index, gridOffset],\n  );\n\n  /* Calculate reactive styles by calling each effect's `getStyle` function\n   * KNOWN ISSUE: If multiple effects output a style containing a `transform` object, the styles will not be combined correctly.\n   * AKA: The latest effect.getStyle()'s `transform` will overwrite the previous one.\n   * Currently this isn't an issue since only one of our effects is using the transform property.\n   */\n  const reactiveStyles: React.CSSProperties = useMemo(() => {\n    // combine all styles from all effects\n    return (effects ?? []).reduce((prevStyle: React.CSSProperties, curEffect: ItemStyleEffect) => {\n      return {\n        ...prevStyle,\n        ...curEffect.getStyle({ itemPosition, mousePosition, centerPosition: gridCenter }),\n      };\n    }, {} as React.CSSProperties);\n  }, [effects, itemPosition, mousePosition, gridCenter]);\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        overflow: 'visible',\n        width: grid.unitSize.width,\n        height: grid.unitSize.height,\n        ...reactiveStyles,\n      }}>\n      {children}\n    </div>\n  );\n};\n\nexport const ReactiveGridItem = React.memo(ReactiveGridItemElement);\n","import { useContext } from 'react';\nimport { MousePositionContext } from '../contexts';\n\nexport const useMousePositionContext = () => useContext(MousePositionContext);\n","import React, { useCallback, useMemo, useState } from 'react';\nimport Measure, { BoundingRect, ContentRect } from 'react-measure';\nimport 'tailwindcss/tailwind.css';\nimport { MousePositionContextProvider } from '../../../contexts';\nimport { useDragDisplacement } from '../../../hooks';\nimport {\n  add2D,\n  CartesianUtil,\n  GridUtil,\n  Index2D,\n  normalize2D,\n  Point2D,\n  ShiftedGrid,\n  Size2D,\n  subtract2D,\n} from '../../../libs';\nimport {\n  createEdgeFadeEffect,\n  createMagnificationEffect,\n  ItemStyleEffect,\n} from '../../../types/ItemStyleEffect';\nimport { BoundingRectUtil } from '../../../utils';\nimport { ReactiveGridItem } from './ReactiveGridItem';\n\ninterface ReactiveGridProps<T> {\n  itemRadius: number;\n  itemSpacing: number;\n  magnification: number;\n  effectRadius: number;\n  items: T[];\n  renderItem: (item: T, index: number, size: Size2D) => React.ReactElement | string | null;\n}\n\n/*\n I would love to make ReactiveGridElement a React.FC, however since there are generic types associated with ReactiveGridProps we cannot do this.\n There are some good resources here for why this needs to be done this way https://wanago.io/2020/03/09/functional-react-components-with-generic-props-in-typescript/\n It's just a limitation of typescript.  Here's another good resource: https://stackoverflow.com/questions/53958028/how-to-use-generics-in-props-in-react-in-a-functional-component\n\n Because of the way we will use ReactiveGrid in this project, this method will work, albeit a bit more confusing and verbose should we need to match the exact functionality of React.FC in the future\n */\nconst ReactiveGridElement: <T>(props: ReactiveGridProps<T>) => React.ReactElement = (props) => {\n  // destructure props\n  const { itemRadius, itemSpacing, magnification, effectRadius, items, renderItem } = props;\n\n  /* HOOKS */\n  const dragDisplacement = useDragDisplacement({\n    useMomentum: true,\n    damping: 0.95,\n  });\n\n  // state vars\n  const [gridCenter, setGridCenter] = useState<Point2D>({ x: 0, y: 0 });\n  const [windowedBounds, setGridBounds] = useState<BoundingRect>(\n    BoundingRectUtil.emptyBoundingRect,\n  );\n\n  // callbacks\n\n  // when the grid changes size we need to update its center\n  const handleResize = useCallback((info: ContentRect) => {\n    const { bounds } = info;\n    if (bounds !== undefined) {\n      setGridCenter(BoundingRectUtil.getCenter(bounds));\n      setGridBounds(bounds);\n    }\n  }, []);\n\n  // when item spacing or item radius changes, we need to recreate the grid math functions\n  const grid: ShiftedGrid = useMemo(() => {\n    // We need to adjust the position of the gridCenter since our container doesn't start at the top-left of the page\n    const containerTopLeft: Point2D = {\n      x: windowedBounds.left,\n      y: windowedBounds.top,\n    };\n\n    const halfItemSizeOffset: Point2D = {\n      x: 0.5 * (itemRadius + itemSpacing),\n      y: 0.5 * (itemRadius + itemSpacing),\n    };\n\n    const offsetCenter = add2D(halfItemSizeOffset, subtract2D(gridCenter, containerTopLeft));\n    return GridUtil.createShiftedGrid(itemRadius, itemSpacing, offsetCenter);\n  }, [itemRadius, itemSpacing, gridCenter, windowedBounds]);\n\n  // calculate scrollOffset\n  const scrollOffset: Point2D = useMemo(() => {\n    return dragDisplacement;\n  }, [dragDisplacement, gridCenter]);\n\n  // scaledScrollOffset is in grid coordinate space\n  const scaledScrollOffset = useMemo(\n    () => normalize2D(scrollOffset, grid.unitSize),\n    [grid.unitSize, scrollOffset],\n  );\n\n  // Calculate array of items in windowed scroll area\n  const gridCoordsInWindowedScrollArea: Index2D[] = useMemo(() => {\n    // Define some useful constants\n    const scaledWindowedBounds = BoundingRectUtil.getNormalized(windowedBounds, grid.unitSize);\n    const ceilOfWidth = Math.ceil(scaledWindowedBounds.width);\n    const ceilOfHeight = Math.ceil(scaledWindowedBounds.height);\n    const ceilOfWidthPlusOne = ceilOfWidth + 1;\n    const ceilOfHeightPlusOne = ceilOfHeight + 1;\n\n    // Use a double-nested loop to collect the gridCoords we need to show inside this windowed scroll area\n    const gridCoords: Index2D[] = [];\n\n    for (let x = -1; x < ceilOfWidthPlusOne; ++x) {\n      for (let y = -1; y < ceilOfHeightPlusOne; ++y) {\n        // Get the cartesian point of this (x, y) coord inside the windowed scroll area\n        const cartPoint = {\n          x: x - 0.5 * ceilOfWidth - scaledScrollOffset.x,\n          y: y - 0.5 * ceilOfHeight - scaledScrollOffset.y,\n        };\n        // Convert the cartPoint to a gridPoint\n        const gridCoord = CartesianUtil.cartToGrid(cartPoint);\n\n        // Add it to our gridCoords array\n        gridCoords.push(gridCoord);\n      }\n    }\n    return gridCoords;\n  }, [grid, windowedBounds, scrollOffset]);\n\n  // Transform mouse position\n  const adjustMousePosition = useCallback(\n    (inputMousePosition: Point2D): Point2D => {\n      const windowedTopLeftPosition: Point2D = {\n        x: windowedBounds.left,\n        y: windowedBounds.top,\n      };\n      return subtract2D(inputMousePosition, windowedTopLeftPosition);\n    },\n    [windowedBounds],\n  );\n\n  /* ItemStyleEffects */\n  const effects = useMemo(() => {\n    // create magnify effect\n    const magnifyEffect = createMagnificationEffect(effectRadius, magnification);\n\n    // create edgeFade effect\n    const fadeDropOffDistance = Math.SQRT1_2 * Math.min(grid.unitSize.width, grid.unitSize.height);\n    const edgeFadeEffect: ItemStyleEffect = createEdgeFadeEffect(\n      windowedBounds.width * 0.4,\n      fadeDropOffDistance,\n    );\n\n    return [edgeFadeEffect, magnifyEffect];\n  }, [effectRadius, magnification, windowedBounds.width, grid.unitSize]);\n\n  /* RENDER */\n  return (\n    <MousePositionContextProvider transformMousePosition={adjustMousePosition}>\n      <Measure bounds onResize={handleResize}>\n        {({ measureRef }) => (\n          <>\n            <div ref={measureRef} className=\"w-full h-full\">\n              {gridCoordsInWindowedScrollArea.map((gridCoord: Index2D) => {\n                const index = GridUtil.coordToIndex(gridCoord);\n                const item = items[index];\n\n                if (item === undefined) {\n                  return null;\n                }\n\n                return (\n                  <ReactiveGridItem\n                    key={`item_${index}`}\n                    grid={grid}\n                    index={index}\n                    effects={effects}\n                    gridCenter={{\n                      x: 0.5 * windowedBounds.width,\n                      y: 0.5 * windowedBounds.height,\n                    }}\n                    gridOffset={scrollOffset}>\n                    {renderItem(item, index, {\n                      width: grid.itemRadius * 2.0,\n                      height: grid.itemRadius * 2.0,\n                    })}\n                  </ReactiveGridItem>\n                );\n              })}\n            </div>\n          </>\n        )}\n      </Measure>\n    </MousePositionContextProvider>\n  );\n};\n\n// Because of our crazy typed functional component with generics in the props, we also need to use a modified React.memo to optimize this beast.\n// See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/37087#issuecomment-542793243 for more on this.\n\nconst typedMemo: <T>(c: T) => T = React.memo;\n\nexport const ReactiveGrid = typedMemo(ReactiveGridElement);\n","import React, { useCallback, useState } from 'react';\nimport Measure, { ContentRect } from 'react-measure';\nimport 'tailwindcss/tailwind.css';\nimport { Size2D } from '../../libs';\nimport { useSelectEmojis } from '../../store/emojiList/selectors';\nimport { EmojiLink, ReactiveGrid } from '../UI';\n\ntype EmojiBrowserPageProps = {};\n\nconst EmojiBrowserPageElement: React.FC<EmojiBrowserPageProps> = (props) => {\n  const emojis = useSelectEmojis();\n\n  const [gridSize, setGridSize] = useState<Size2D>({ width: 0, height: 0 });\n\n  const handleResize = useCallback((info: ContentRect) => {\n    if (info?.bounds === undefined) {\n      return;\n    }\n\n    const sideLength = 0.5 * Math.min(info.bounds.width, info.bounds.height);\n    setGridSize({\n      width: sideLength,\n      height: sideLength,\n    });\n  }, []);\n\n  return (\n    <Measure bounds onResize={handleResize}>\n      {({ measureRef }) => (\n        <div\n          ref={measureRef}\n          className=\"w-full h-full\"\n          style={{\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center',\n          }}\n          >\n          <div\n            className=\"p-4\"\n            style={{\n              width: gridSize.width,\n              height: gridSize.height,\n            }}>\n            <ReactiveGrid\n              magnification={1}\n              effectRadius={200}\n              itemRadius={30}\n              itemSpacing={20}\n              items={emojis}\n              renderItem={(item, index, itemSize) => (\n                <EmojiLink emoji={item} itemSize={itemSize} />\n              )}\n            />\n          </div>\n        </div>\n      )}\n    </Measure>\n  );\n};\n\nexport const EmojiBrowserPage = React.memo(EmojiBrowserPageElement);\n","import { Emoji } from '../../models';\nimport {\n  EmojiListActionTypes,\n  EmojiListRequestBegin,\n  EmojiListRequestFail,\n  EmojiListRequestSucceed,\n} from './actionTypes';\nimport { EmojiListActionError } from './types';\n\n// Action Creators\nexport const EmojiListActionCreator = {\n  fetchAll: (): EmojiListRequestBegin => ({\n    type: EmojiListActionTypes.BeginFetchRequest,\n  }),\n  fetchSuccess: (data: Emoji[]): EmojiListRequestSucceed => ({\n    type: EmojiListActionTypes.FetchRequestDidSucceed,\n    payload: data,\n  }),\n  fetchFailure: (error: EmojiListActionError): EmojiListRequestFail => ({\n    type: EmojiListActionTypes.FetchRequestDidFail,\n    payload: error,\n  }),\n};\n","import React, { useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { Route, Switch } from 'react-router-dom';\nimport 'tailwindcss/tailwind.css';\nimport { EmojiBrowserPage } from './components';\nimport { EmojiListActionCreator } from './store/emojiList/actionCreators';\n\nfunction App() {\n  const dispatch = useDispatch();\n\n  // app startup effects\n  useEffect(() => {\n    // load all emojis\n    dispatch(EmojiListActionCreator.fetchAll());\n  });\n\n  return (\n    <div className=\"w-full h-full bg-black\">\n      <Switch>\n        <Route exact path=\"/\" component={EmojiBrowserPage} />\n\n        <Route exact path=\"/:emoji\" component={EmojiBrowserPage} />\n        {/* TODO: Make this nice!\n        <Route exact path=\"/:emoji\" component={EmojiDetailModal} />\n        */}\n      </Switch>\n    </div>\n  );\n}\n\nexport default App;\n","import { Category } from '../../models';\nimport { CategoryListActionError } from './types';\n\n// Action Types Enum\nexport enum CategoryListActionTypes {\n  BeginFetchRequest = 'CategoryListBeginFetchRequest',\n  FetchRequestDidSucceed = 'CategoryListFetchRequestDidSucceed',\n  FetchRequestDidFail = 'CategoryListFetchRequestDidFail',\n}\n\n// Action Object Types\nexport type CategoryListRequestBegin = {\n  type: CategoryListActionTypes.BeginFetchRequest;\n};\n\nexport type CategoryListRequestSucceed = {\n  type: CategoryListActionTypes.FetchRequestDidSucceed;\n  payload: Category[];\n};\n\nexport type CategoryListRequestFail = {\n  type: CategoryListActionTypes.FetchRequestDidFail;\n  payload: CategoryListActionError;\n};\n\n// Action Types Union\nexport type CategoryListActions =\n  | CategoryListRequestBegin\n  | CategoryListRequestSucceed\n  | CategoryListRequestFail;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { CategoryListActions, CategoryListActionTypes } from './actionTypes';\nimport { CategoryListState } from './types';\n\nconst INITIAL_STATE: CategoryListState = {\n  loading: false,\n  error: undefined,\n  items: [],\n};\n\nexport const categoryListReducer = (\n  state = INITIAL_STATE,\n  action: CategoryListActions,\n): CategoryListState => {\n  switch (action.type) {\n    case CategoryListActionTypes.BeginFetchRequest:\n      return {\n        ...state,\n        loading: true,\n      };\n    case CategoryListActionTypes.FetchRequestDidSucceed:\n      return {\n        ...state,\n        loading: false,\n        items: action.payload,\n        error: undefined,\n      };\n    case CategoryListActionTypes.FetchRequestDidFail:\n      return {\n        ...state,\n        loading: false,\n        items: [],\n        error: action.payload,\n      };\n    default:\n      return state;\n  }\n};\n","import { EmojiListActions, EmojiListActionTypes } from './actionTypes';\nimport { EmojiListState } from './types';\n\nconst INITIAL_STATE: EmojiListState = {\n  loading: false,\n  error: undefined,\n  items: [],\n};\n\nexport const emojiListReducer = (\n  state = INITIAL_STATE,\n  action: EmojiListActions,\n): EmojiListState => {\n  switch (action.type) {\n    case EmojiListActionTypes.BeginFetchRequest:\n      return {\n        ...state,\n        loading: true,\n      };\n    case EmojiListActionTypes.FetchRequestDidSucceed:\n      return {\n        ...state,\n        loading: false,\n        items: action.payload,\n        error: undefined,\n      };\n    case EmojiListActionTypes.FetchRequestDidFail:\n      return {\n        ...state,\n        loading: false,\n        items: [],\n        error: action.payload,\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from 'redux';\nimport { categoryListReducer } from './categoryList/reducer';\nimport { emojiListReducer } from './emojiList/reducer';\n\nexport const rootReducer = combineReducers({\n  categories: categoryListReducer,\n  emojis: emojiListReducer,\n});\n\nexport type AppState = ReturnType<typeof rootReducer>;\n","import * as t from 'io-ts';\n\nconst CategoryModel = t.type({\n  slug: t.string,\n  subCategories: t.array(t.string),\n});\n\nexport const Category = t.exact(CategoryModel);\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type Category = t.TypeOf<typeof Category>;\n","import * as t from 'io-ts';\n\nconst EmojiModel = t.type({\n  slug: t.string,\n  character: t.string,\n  unicodeName: t.string,\n  codePoint: t.string,\n  group: t.string,\n  subGroup: t.string,\n});\n\n// t.exact strips extra keys that aren't defined in the t.type model definition above\nexport const Emoji = t.exact(EmojiModel);\n\n// overloading the name of the model with a matching type allows us to write terse code which is more semantically flexible and pretty\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type Emoji = t.TypeOf<typeof Emoji>;\n","import { EnvUtil } from './utils';\n\nexport const config = {\n  api: {\n    baseURL: 'https://emoji-api.com',\n    accessKey: EnvUtil.openEmojiAPIKey,\n  },\n};\n","import axios from 'axios';\nimport { config } from '../config';\n\nexport const client = axios.create({\n  timeout: 20000,\n  baseURL: config.api.baseURL,\n  params: {\n    access_key: config.api.accessKey,\n  },\n});\n","import * as t from 'io-ts';\nimport { Emoji } from '../../models';\nimport { CodecUtil } from '../../utils';\nimport { client } from '../client';\n\nasync function listAll(): Promise<Emoji[]> {\n  const { data } = await client.get('/emojis');\n\n  return CodecUtil.decode(t.array(Emoji), data);\n}\n\nexport const emojis = {\n  listAll,\n};\n","import { categories, emojis } from './methods';\n\nexport const api = {\n  categories,\n  emojis,\n};\n","import { all, call, put, SagaReturnType, takeLatest } from 'redux-saga/effects';\nimport { api } from '../../api';\nimport { EmojiListActionCreator } from './actionCreators';\nimport { EmojiListActionTypes } from './actionTypes';\n\n/*\n  Worker Saga: Fired on BeginFetchRequest\n*/\nfunction* fetchEmojiListSaga() {\n  try {\n    const emojis: SagaReturnType<typeof api.emojis.listAll> = yield call(api.emojis.listAll);\n    yield put(EmojiListActionCreator.fetchSuccess(emojis));\n  } catch (error) {\n    yield put(EmojiListActionCreator.fetchFailure(`${error}`));\n  }\n}\n\n/*\n  Starts worker saga on latest dispatched BeginFetchRequest action\n*/\nexport function* emojiListSaga() {\n  yield all([takeLatest(EmojiListActionTypes.BeginFetchRequest, fetchEmojiListSaga)]);\n}\n","import { all, fork } from 'redux-saga/effects';\nimport { emojiListSaga } from './emojiList/sagas';\n\nexport function* rootSaga() {\n  yield all([fork(emojiListSaga)]);\n}\n","import createSagaMiddleware from '@redux-saga/core';\nimport { applyMiddleware, createStore } from 'redux';\nimport logger from 'redux-logger';\nimport { rootReducer } from './rootReducer';\nimport { rootSaga } from './rootSaga';\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst middleware = applyMiddleware(sagaMiddleware, logger);\n\nexport const store = createStore(rootReducer, middleware);\n\nsagaMiddleware.run(rootSaga);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport { store } from './store';\n\nReactDOM.render(\n  <BrowserRouter>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </BrowserRouter>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","/*\n  Each point in an ShiftedGrid has six adjacent points.\n  Thus, there are six directions one can move in to reach an adajcent point.\n*/\n\nexport enum GridDirection {\n  NX, // negative x\n  PX, // positive x\n  NXNY, // negative x, negative y\n  NXPY, // negative x, positive y\n  PXNY, // positive x, negative y\n  PXPY, // positive x, positive y\n}\n\n// This is a map of GridDirections to y=mx+b line slopes in Cartesian coords\n\nexport const CartesianSlope: { [K in GridDirection]: number } = {\n  [GridDirection.NX]: 0,\n  [GridDirection.PX]: 0,\n  [GridDirection.NXNY]: 2,\n  [GridDirection.PXPY]: 2,\n  [GridDirection.PXNY]: -2,\n  [GridDirection.NXPY]: -2,\n};\n\n// This is a mapping of the Direction one must traverse from the origin to reach a specific RingCorner\n// The index is inferred to be a RingCorner value in the range [0, 5]\nexport const DirectionFromCenterToCorner: GridDirection[] = [\n  GridDirection.PX, // center -> p0\n  GridDirection.PXPY, // center -> p1\n  GridDirection.NXPY, // center -> p2\n  GridDirection.NX, //  center -> p3\n  GridDirection.NXNY, // center -> p4\n  GridDirection.PXNY, // center -> p5 (actually not entirely accurate, you have to add (1, 0) to get to the corner at p5)\n];\n","import { BoundingRect } from 'react-measure';\nimport { Point2D, Scale2D, Size2D } from '../libs';\n\nexport const BoundingRectUtil = (function () {\n  function getCenter(rect: BoundingRect): Point2D {\n    return {\n      x: 0.5 * (rect.left + rect.right),\n      y: 0.5 * (rect.top + rect.bottom),\n    };\n  }\n\n  function getScaled(rect: BoundingRect, scale: Scale2D): BoundingRect {\n    const center = getCenter(rect);\n    return {\n      width: scale.x * rect.width,\n      height: scale.y * rect.height,\n      top: scale.y * (rect.top - center.y),\n      left: scale.x * (rect.left - center.x),\n      bottom: scale.y * (rect.bottom - center.y),\n      right: scale.x * (rect.right - center.x),\n    };\n  }\n\n  function getNormalized(rect: BoundingRect, gridSize: Size2D): BoundingRect {\n    const inverseScale: Scale2D = {\n      x: 1 / gridSize.width,\n      y: 1 / gridSize.height,\n    };\n    return getScaled(rect, inverseScale);\n  }\n\n  const emptyBoundingRect: BoundingRect = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n  };\n\n  return {\n    getCenter,\n    getScaled,\n    getNormalized,\n    emptyBoundingRect,\n  };\n})(); // End anonymous function for BoundingRectUtil\n","import { pipe } from 'fp-ts/function';\nimport { fold } from 'fp-ts/lib/Either';\nimport * as t from 'io-ts';\n\nexport class DecodeError extends Error {\n  name = 'DecodeError';\n}\n\nexport const CodecUtil = {\n  // use promises to decode an io-ts model\n  decode: <A, O = A, I = unknown>(type: t.Type<A, O, I>, data: I): Promise<A> => {\n    return new Promise((resolve, reject) => pipe(type.decode(data), fold(reject, resolve)));\n  },\n};\n","export const EnvUtil = {\n  openEmojiAPIKey: process.env.REACT_APP_OPEN_EMOJI_API_KEY,\n};\n","export const MathUtil = {\n  SQRT3: Math.sqrt(3.0),\n  ISQRT3: 1.0 / Math.sqrt(3.0),\n  modulo: function (a: number, b: number) {\n    return ((a % b) + b) % b;\n  },\n};\n","export const GridConstants = {\n  EPSILON: 0.00001,\n  diagonallyAdjacentNodeDistance: Math.sqrt(1.25),\n  yAxisCompression: 1.0 / Math.sqrt(1.25),\n};\n","export * from './2DTypes';\nexport * from './GridDirection';\nexport * from './GridQuadrant';\nexport * from './GridRay';\nexport * from './RingCorner';\nexport * from './ShiftedGrid';\nexport * from './SlopeInterceptLine';\n","export * from './EdgeFadeEffect';\nexport * from './ItemStyleEffect';\nexport * from './MagnificationEffect';\n","export * from './constants';\nexport * from './types';\nexport * from './utils';\n","export type XYNumeric = {\n  x: number;\n  y: number;\n};\n\n// I wish there was a way to statically enforce x and y to be integers.\n// (without using io-ts runtime validation)\n\n// Basically the names for these types are just hints to the developer and make the code more readable in my opinion\nexport type Index2D = XYNumeric;\nexport type Point2D = XYNumeric;\nexport type Vector2D = XYNumeric;\nexport type Scale2D = XYNumeric;\nexport type Velocity2D = XYNumeric;\n\nexport const origin2D: XYNumeric = { x: 0, y: 0 };\n\nexport type Size2D = {\n  width: number;\n  height: number;\n};\n\n// TODO: look for a better way to do this...\nexport function add2D<T extends XYNumeric>(a: T, b: T): T {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y,\n  } as T;\n}\n\nexport function subtract2D<T extends XYNumeric>(a: T, b: T): T {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y,\n  } as T;\n}\n\n// returns { -x, -y } for a given XYNumeric\nexport function negate2D<T extends XYNumeric>(a: T): T {\n  return {\n    x: -a.x,\n    y: -a.y,\n  } as T;\n}\n\n// Normalizes a given XYNumeric by a Size2D\n\nexport function normalize2D<T extends XYNumeric>(a: T, s: Size2D): T {\n  return {\n    x: a.x / s.width,\n    y: a.y / s.height,\n  } as T;\n}\n","import { GridDirection } from './GridDirection';\n\n// A GridQuadrant is one of six sections of the grid.\n\nexport enum GridQuadrant {\n  PXPY = 0,\n  PY = 1,\n  NXPY = 2,\n  NXNY = 3,\n  NY = 4,\n  PXNY = 5,\n}\n\n// Map of GridQuadrant to the GridDirection from the origin to the corner of a hexagonal ring\n\nexport const CornerDirectionForQuadrant: { [K in GridQuadrant]: GridDirection } = {\n  [GridQuadrant.PXPY]: GridDirection.PX,\n  [GridQuadrant.PY]: GridDirection.PXPY,\n  [GridQuadrant.NXPY]: GridDirection.NXPY,\n  [GridQuadrant.NXNY]: GridDirection.NX,\n  [GridQuadrant.NY]: GridDirection.NXNY,\n  [GridQuadrant.PXNY]: GridDirection.PXNY,\n};\n\n// Map of GridQuadrants to their associated intersector line GridDirection\n\nexport const IntersectorDirectionForQuadrant: { [K in GridQuadrant]: GridDirection } = {\n  [GridQuadrant.PXPY]: GridDirection.PXNY,\n  [GridQuadrant.PY]: GridDirection.PX,\n  [GridQuadrant.NXPY]: GridDirection.PXPY,\n  [GridQuadrant.NXNY]: GridDirection.NXPY,\n  [GridQuadrant.NY]: GridDirection.NX,\n  [GridQuadrant.PXNY]: GridDirection.NXNY,\n};\n","/* There are 6 ring corners.  Corner 0 is always the start, and they increase counter-clockwisely like so:\n    +y\n    ^\n    |      p2 . p1\n    |     .       .\n    |    p3       p0\n    |     .         .\n    |      p4 . . p5\n    |\n    -----------------> +x\n*/\n\nexport const RingCorners = {\n  first: 0,\n  second: 1,\n  third: 2,\n  fourth: 3,\n  fifth: 4,\n  sixth: 5,\n} as const;\n\nexport type RingCorner = typeof RingCorners[keyof typeof RingCorners];\n\nexport const RingCornerIndices = Object.values(RingCorners);\n","import { CartesianUtil, origin2D } from '../../libs';\nimport { ItemStyleEffect } from './ItemStyleEffect';\n\n// this creates an edge-fade effect which produces an opacity value that drops off from 100% -> 0% between (radius, radius + dropoff)\n// please make fadeDropOffDistance a non-zero number, please.\nexport function createEdgeFadeEffect(startFadeOutDistance: number, fadeDropOffDistance: number): ItemStyleEffect {\n  // privately-scoped getOpacity function\n  function getOpacity(distToCenter: number): number {\n    if (distToCenter <= startFadeOutDistance) {\n      return 1;\n    } else {\n      return Math.max(0, 1 + (startFadeOutDistance - distToCenter) / fadeDropOffDistance);\n    }\n  }\n\n  return {\n    // itemPosition is intended to be the position of the ReactiveGridItem\n    // effectPosition is intended to be the center of the ReactiveGrid\n    getStyle: function ({ itemPosition, centerPosition }) {\n      return {\n        opacity: getOpacity(CartesianUtil.getDistance(itemPosition, centerPosition ?? origin2D)),\n      };\n    },\n  };\n}\n","import { origin2D, Point2D, subtract2D } from '../../libs';\nimport { ItemStyleEffect } from './ItemStyleEffect';\n\n/*\nThis magnification effect was pretty fun to figure out.  We could split it into two effects; one for scale and one for position,\nhowever they are mathematically related quite intimately, and it improves the program's efficiency to keep them together too!\n*/\n\nexport const createMagnificationEffect = (function () {\n  // OK, so first we define our mathematical helper functions\n\n  /**\n   * @description A factory which creates an optimized and efficient magnification scaling function\n   * @param {number} r - Effect radius\n   * @param {number} s - Maximum scale\n   * @return {number} - The magnified scale\n   */\n  function createScaleFunction(r: number, s: number) {\n    // define some convenient vars\n\n    const a = 0.5 * s;\n    const b = Math.PI / r;\n\n    // scale helper function (the curve portion, single-dimension, unbounded, non-piecewise)\n    function fScale(t: number, p: number): number {\n      return 1.0 + a * (Math.cos(b * (t - p)) + 1.0);\n    }\n\n    /*\n     * Now we can construct the parametric (single-dimension only) piecewise versions of these functions\n     * This function's value follows the fScale curve when t is within the effect range, otherwise returns 1\n     */\n\n    function pScale(t: number, p: number): number {\n      return Math.abs(t - p) < r ? fScale(t, p) : 1;\n    }\n\n    /*\n     * Now that we have all the pieces we can return the two-dimensional scale function\n     */\n\n    return function (itemPosition: Point2D, effectPosition: Point2D): number {\n      // scale should be minimum of parametric scale for x and y\n      return Math.min(\n        pScale(itemPosition.x, effectPosition.x),\n        pScale(itemPosition.y, effectPosition.y),\n      );\n    };\n  }\n\n  /**\n   * @description A factory which creates an optimized and efficient magnification displacement function\n   * @param {number} r - Effect radius\n   * @param {number} s - Maximum scale\n   * @return {Point2D} - The displaced point\n   */\n  function createDisplacementFunction(r: number, s: number) {\n    // define some convenient vars\n\n    const a = (2.0 + s) / 2.0;\n    const b = (r * s) / (2.0 * Math.PI);\n    const c = Math.PI / r;\n\n    const r1a = r * (1 - a);\n    const bsincr = b * Math.sin(c * r);\n\n    /*\n     * Construct the piecewise displacement function - see Desmos graph in research folder for how this was calculated\n     */\n    function pDisp(t: number, p: number) {\n      if (t < p - r) {\n        // t is less than point of interest, out of effect range\n        return t + r1a + bsincr;\n      }\n      if (t > p + r) {\n        // t is greater than point of interest, out of effect range\n        return t - r1a + bsincr;\n      }\n      // here we can safely assume t is within the effect range\n      return a * (t - p) + b * Math.sin(c * (t - p)) + p;\n    }\n\n    /*\n     * Now we can return the two-dimensional displacement function\n     */\n\n    return function (itemPosition: Point2D, effectPosition: Point2D): Point2D {\n      return {\n        x: pDisp(itemPosition.x, effectPosition.x),\n        y: pDisp(itemPosition.y, effectPosition.y),\n      };\n    };\n  }\n\n  /**\n   * HERE IT IS!\n   * The actual factory function which creates the ItemStyleEffect\n   */\n\n  return function (effectRadius: number, maximumScale: number): ItemStyleEffect {\n    const getTranslation = createDisplacementFunction(effectRadius, maximumScale);\n    const getScale = createScaleFunction(effectRadius, maximumScale);\n\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      getStyle: function ({ itemPosition, centerPosition }) {\n        const effectPosition = centerPosition || origin2D;\n        const { x, y } = getTranslation(itemPosition, effectPosition);\n        const s = getScale(itemPosition, effectPosition);\n\n        return {\n          transform: `translate(${x}px, ${y}px) scale(${s}, ${s})`,\n        };\n      }, // end of getStyle func\n    }; // end of return object\n  }; // end of factory function\n})();\n","/*\n\nThis file contains operations that transform between cartesian space and ShiftedGrid space\n\nIt also includes convenient classes related to general cartesian geometry\n\n*/\nimport { MathUtil } from '../../../utils';\nimport { Index2D, Point2D } from '../types/2DTypes';\n\n/**\n * @name CartesianUtil\n * @description - Contains helper functions for working with cartesian coordinates\n */\nexport const CartesianUtil = {\n  /**\n   * @name gridToCart\n   * @description - Given a cartesian coordinate, find the nearest coordinate on a ShiftedGrid\n   * @param {Index2D} gridCoord - The grid coordinate whose cartesian point we want to calculate\n   * @return {Point2D} - The cartesian coordinate of the gridCoord\n   */\n  gridToCart: function ({ x: cx, y: cy }: Index2D): Point2D {\n    const ry = Math.round(cy);\n    const k = 0.5 * MathUtil.modulo(ry, 2);\n    return {\n      x: Math.round(cx - k) + k,\n      y: ry,\n    };\n  },\n\n  /**\n   * @name cartToGrid\n   * @description - Given a ShiftedGrid coordinate, calculate the corresponding cartesian point\n   * @param {Point2D} cartPoint - The cartesian point whose gridCoord we want to calculate\n   * @return {Index2D} - The coordinate on the ShiftedGrid closest to the input cartPoint\n   */\n  cartToGrid: function ({ x: gx, y: gy }: Point2D): Index2D {\n    return {\n      x: Math.floor(gx),\n      y: Math.floor(gy),\n    };\n  },\n\n  /**\n   * @name getDistance\n   * @param {Point2D} a - An arbitrary point in cartesian space\n   * @param {Point2D} b - Another arbitrary point in cartesian space\n   * @return {number} - the distance between points a and b\n   *\n   * check this out btw https://jsben.ch/stsBd\n   */\n  getDistance: function (a: Point2D, b: Point2D): number {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n};\n","import { CartesianSlope, GridDirection, GridRay, Index2D, SlopeInterceptLine } from '../types';\nimport { xComponentAdjustment as dx } from '../utils';\nimport { CartesianUtil } from './CartesianUtil';\n\n// I am making factory methods instead of classes because my research and intuition both indicate that this will be more performant and efficient when these functions are run many times\n// At some point I will make the time to benchmark this and see if my hypothesis is correct.\n\nexport function createGridRay(startCoord: Index2D, direction: GridDirection): GridRay {\n  const { x: p1x, y: p1y } = startCoord;\n\n  return {\n    startCoord,\n    direction,\n    // TODO: this should be a dedicated util function, not an instance method\n    contains: function ({ x: p2x, y: p2y }: Index2D): boolean {\n      switch (direction) {\n        case GridDirection.NX:\n          return p1y === p2y && p2x <= p1x;\n\n        case GridDirection.PX:\n          return p1y === p2y && p2x >= p1x;\n\n        case GridDirection.NXNY:\n          // { p2x: p1x - dx(p1y, m), p2y: p1y - m };\n          // m = p1y - p2y\n          // p2x === p1x - dx(p1y, m)\n\n          return p2x <= p1x && p2y <= p1y && p2x === p1x - dx(p1y, p1y - p2y);\n\n        case GridDirection.NXPY:\n          // { p2x: p1x - dx(p1y, m), p2y: p1y + m };\n          // m = p2y - p1y\n          // p2x === p1x - dx(p1y, m)\n\n          return p2x <= p1x && p2y >= p1y && p2x === p1x - dx(p1y, p2y - p1y);\n\n        case GridDirection.PXNY:\n          // { p2x: p1x + m - dx(p1y, m), p2y: p1y - m };\n          // m = p1y - p2y\n          // p2x === p1x + m - dx(p1y, m)\n          return p2x >= p1x && p2y <= p1y && p2x === p1x + (p1y - p2y) - dx(p1y, p1y - p2y);\n\n        case GridDirection.PXPY:\n          // { p2x: p1x + m - dx(p1y, m), p2y: p1y + m }\n          // m = p2y - p1y\n          // p2x === p1x + m - dx(p1y, m)\n\n          return p2x >= p1x && p2y >= p1y && p2x === p1x + (p2y - p1y) - dx(p1y, p2y - p1y);\n      }\n    },\n    // TODO: this should be a dedicated util function, not an instance method\n    asCartLine(): SlopeInterceptLine {\n      const slope = CartesianSlope[this.direction];\n\n      const { x: cx, y: cy } = CartesianUtil.gridToCart(startCoord);\n\n      const intercept = cy - slope * cx;\n\n      return { slope, intercept };\n    },\n  };\n}\n","import { GridConstants } from '../constants';\nimport { Point2D, SlopeInterceptLine } from '../types';\n\nconst { EPSILON } = GridConstants;\n\nexport function getLineIntersection(\n  line1: SlopeInterceptLine,\n  line2: SlopeInterceptLine,\n): Point2D | undefined {\n  const slopeDifference = line1.slope - line2.slope;\n\n  // If slopes are computationally similar enough, we assume they don't intersect.\n  if (Math.abs(slopeDifference) <= EPSILON) {\n    return undefined;\n  }\n\n  const x = (line2.intercept - line1.intercept) / slopeDifference;\n  const y = line1.slope * x + line1.intercept;\n\n  return { x, y };\n}\n","import { GridQuadrant, Index2D } from '../types';\n\nexport const getGridQuadrant = (function () {\n  function d(t: number) {\n    return Math.ceil(2 * t);\n  }\n\n  return function ({ x, y }: Index2D): GridQuadrant {\n    if (y < d(x) && y >= 0) {\n      return GridQuadrant.PXPY;\n    }\n\n    if (y > d(-x) && y >= 0) {\n      return GridQuadrant.PY;\n    }\n\n    if (y <= d(-x) && y > 0) {\n      return GridQuadrant.NXPY;\n    }\n\n    if (y >= d(x + 1) && y <= 0) {\n      return GridQuadrant.NXNY;\n    }\n\n    if (y < d(x + 2) && y < d(1 - x) - 1) {\n      return GridQuadrant.NY;\n    }\n\n    return GridQuadrant.PXNY;\n  };\n})();\n","/*\nThe way we will be using the ShiftedGrid and laying out nodes within it will rely heavily on the idea that a grid is a series of connected hexagonal spirals.\nHere are some useful functions for various properties of Rings within an ShiftedGrid\n*/\n\nimport { add2D, DirectionFromCenterToCorner, Index2D, RingCorner } from '../types';\nimport { GridUtil } from './GridUtil';\n\n// Returns the count of all nodes up to and including a ring specified by index\nexport function getSumOfAllNodesIncluding(ringIndex: number) {\n  return (ringIndex + 1) * (3 * ringIndex + 1);\n}\n\n// Returns the first index in the given ring\nexport function getFirstNodeIndexInRing(ringIndex: number) {\n  return ringIndex * (3 * ringIndex - 2);\n}\n\n// Returns the index of the ring that contains the nodeIndex\nexport function getRingIndex(nodeIndex: number): number {\n  return Math.floor((-2 + Math.sqrt(4 - 3 * (1 - nodeIndex))) / 3) + 1;\n}\n\n// Returns the RingCorner whose subIndex is less than or equal to the given nodeSubIndex\nexport function getLeadingRingCorner(ringIndex: number, nodeSubIndex: number): RingCorner {\n  if (nodeSubIndex < 5 * ringIndex + 1) {\n    return Math.min(4, Math.floor(nodeSubIndex / Math.max(1, ringIndex))) as RingCorner;\n  } else {\n    return 5;\n  }\n}\n\n// Returns the subIndex of the given RingCorner within a ring\nexport function getRingCornerSubIndex(ringIndex: number, ringCorner: RingCorner): number {\n  // look ma, no branches!\n  return ringCorner * ringIndex + Math.max(0, ringCorner - 4);\n}\n\n// Returns the grid index of the given RingCorner within the full spiral\nexport function getRingCornerIndex(ringIndex: number, ringCorner: RingCorner): number {\n  // this result is equivalent to: firstNodeIndexOfPreviousRing + ringCornerSubIndex\n  // aka: getFirstNodeIndexInRing(ringIndex) + getRingCornerSubIndex(ringIndex, ringCorner);\n  // let's optimize this into an algebraic expression now:\n  // (((ringIndex - 1) + 1) * (3 * (ringIndex - 1) + 1) + (ringCorner * ringIndex + Math.max(0, ringCorner - 4));\n  return ringIndex * (3 * ringIndex + ringCorner - 2) + Math.max(0, ringCorner - 4);\n}\n\n// Returns the Index2D coord of a corner of a ring\nexport const getRingCornerCoord = (function () {\n  // This is just the grid's origin\n  const origin: Index2D = { x: 0, y: 0 };\n\n  return function (ringIndex: number, ringCorner: RingCorner): Index2D {\n    let cornerPoint = GridUtil.traverse(origin, DirectionFromCenterToCorner[ringCorner], ringIndex);\n\n    // special case for corner 5, we need to add 1 to the x-value\n    if (ringCorner === 5) {\n      cornerPoint = add2D(cornerPoint, { x: 1, y: 0 });\n    }\n\n    return cornerPoint;\n  };\n})();\n\n// Returns the RingCorner value of a coord in a ring.  Fast, too!\n// input coord MUST be a CornerPoint, otherwise this result is not valid.\n\nexport function getRingCornerOfCornerCoord({ x: cx, y: cy }: Index2D): RingCorner {\n  if (cy === 0) {\n    return cx < 0 ? 3 : 0;\n  } else if (cy > 0) {\n    return cx >= 0 ? 1 : 2;\n  } else {\n    return cx > 0 ? 5 : 4;\n  }\n}\n","import { GridConstants } from '../constants';\nimport {\n  CornerDirectionForQuadrant,\n  GridDirection,\n  GridQuadrant,\n  Index2D,\n  IntersectorDirectionForQuadrant,\n  origin2D,\n  Point2D,\n  Scale2D,\n  ShiftedGrid,\n  subtract2D,\n} from '../types';\nimport { CartesianUtil } from './CartesianUtil';\nimport { createGridRay } from './GridRayUtil';\nimport { getLineIntersection } from './LineUtil';\nimport { getGridQuadrant } from './QuadrantUtil';\nimport {\n  getFirstNodeIndexInRing,\n  getLeadingRingCorner,\n  getRingCornerCoord,\n  getRingCornerIndex,\n  getRingCornerOfCornerCoord,\n  getRingCornerSubIndex,\n  getRingIndex,\n} from './RingUtil';\n\nconst { EPSILON, diagonallyAdjacentNodeDistance } = GridConstants;\n\n/**\n * @name xComponentAdjustment\n * @description This is a helper function which 'corrects' the x value of the point being traversed to, depending on the y-value of the point being traversed from\n * @param {number} fromPointY - The y-value of the point being traversed from\n * @param {number} traversalMagnitude - The distance over which we are traversing\n * @return {number}\n */\nexport function xComponentAdjustment(fromPointY: number, traversalMagnitude: number): number {\n  if (fromPointY % 2 === 0) {\n    // For diagonal moves, if fromPointY is even we use Math.ceil...\n    return Math.ceil(traversalMagnitude / 2);\n  } else {\n    // ...and if fromPointY is odd we use Math.floor\n    return Math.floor(traversalMagnitude / 2);\n  }\n}\n/**\n * @name GridUtil\n * @description - A collection of helper functions for working with a ShiftedGrid\n */\n\nexport const GridUtil = (function () {\n  /**\n   * @name createShiftedGrid\n   * @description Creates a ShiftedGrid object\n   *\n   * @param {number} itemRadius - The radius of each item in the grid\n   * @param {number} itemSpacing - The spacing between two adjacent items in the grid\n   * @param {Point2D} offsetXY - The offset of the grid center\n   * @param {Scale2D} stretchXY - Scaling factors for the grid axes\n   *\n   * @return {ShiftedGrid}\n   */\n\n  const createShiftedGrid = (function () {\n    const defaultStretchXY: Scale2D = { x: 1.0, y: GridConstants.yAxisCompression };\n    const origin: Point2D = { x: 0, y: 0 };\n\n    return function (\n      itemRadius: number,\n      itemSpacing: number,\n      offsetXY: Point2D = origin,\n      stretchXY: Scale2D = defaultStretchXY,\n    ): ShiftedGrid {\n      const { x: ox, y: oy } = offsetXY;\n      const { x: sx, y: sy } = stretchXY;\n\n      const spaceSize = 2 * itemRadius + itemSpacing;\n\n      const unitSize = {\n        width: sx * spaceSize,\n        height: sy * spaceSize,\n      };\n\n      return {\n        itemRadius,\n        itemSpacing,\n        unitSize,\n\n        gridCoordToScreenPoint: function (coord): Point2D {\n          const { x: cx, y: cy } = CartesianUtil.gridToCart(coord);\n          return {\n            x: ox + unitSize.width * cx,\n            y: oy + unitSize.height * cy,\n          };\n        },\n\n        screenPointToGridCoord: function ({ x: gx, y: gy }): Index2D {\n          const cartPoint = {\n            x: (gx - ox) / unitSize.width,\n            y: (gy - oy) / unitSize.height,\n          };\n          return CartesianUtil.cartToGrid(cartPoint);\n        },\n      };\n    };\n  })();\n\n  /**\n   * @description Translates a point along the grid by a magnitude in a direction\n   * @param {Index2D} p - The starting indices to translate from\n   * @param {Direction} direction - The axis along which to move\n   * @param {number} m - The magnitude along the axis to translate by\n   *\n   * @return {Index2D} - The resulting position after traversal\n   *\n   */\n  function traverse(p: Index2D, direction: GridDirection, m: number): Index2D {\n    switch (direction) {\n      case GridDirection.NX:\n        return { x: p.x - m, y: p.y };\n      case GridDirection.PX:\n        return { x: p.x + m, y: p.y };\n      case GridDirection.NXNY:\n        return { x: p.x - xComponentAdjustment(p.y, m), y: p.y - m };\n      case GridDirection.NXPY:\n        return { x: p.x - xComponentAdjustment(p.y, m), y: p.y + m };\n      case GridDirection.PXNY:\n        return { x: p.x + m - xComponentAdjustment(p.y, m), y: p.y - m };\n      case GridDirection.PXPY:\n        return { x: p.x + m - xComponentAdjustment(p.y, m), y: p.y + m };\n    }\n  }\n\n  /**\n   * @name getDistanceBetween\n   *\n   * @param {Index2D} coordA - Coord A\n   * @param {Index2D} coordB - Coord B\n   * @return {number | undefined} - the distance between two points in a ShiftedGrid if they are colinear.  Otherwise returns undefined.\n   */\n  function getDistanceBetween(coordA: Index2D, coordB: Index2D): number | undefined {\n    // Let's cover the simplest case first.\n    if (Math.abs(coordA.y - coordB.y) < EPSILON) {\n      // distance between points with the same y-value is just the difference in x-value\n      return Math.abs(coordA.x - coordB.x);\n    }\n\n    // Now that that's out of the way...\n\n    // We can easily test if 2 points are colinear in our ShiftedGrid by determining if the slope between the two points matches up with one of the cartesian versions of our GridDirections\n    // We use this cartesian trick because otherwise we'd have to set up an algebraic inequality and solve for variables inside ceil and floor functions and that's pretty difficult...\n    // I may take a crack at that someday...\n\n    const cartPointA: Point2D = CartesianUtil.gridToCart(coordA);\n    const cartPointB: Point2D = CartesianUtil.gridToCart(coordB);\n\n    // Since we already covered the case where the points have the same y-value, we are just looking to see if the slope between the points is within EPSILON of 2.0\n    // If so, then we can consider the points to be colinear and calculate their distance\n\n    const { x: dx, y: dy } = subtract2D(cartPointA, cartPointB);\n\n    // if dx is 0 or close enough, we can return early\n    if (Math.abs(dx) < EPSILON) {\n      // ShiftedGrid does not allow adjacent nodes to be directly above or below each other, so we return undefined by design.\n      return undefined;\n    }\n\n    // Now we check if the slope is too far away from the sacred values 2.0\n    if (Math.abs(2.0 - Math.abs(dy / dx)) > EPSILON) {\n      // It's too far.  Return early, undefined. :(\n      return undefined;\n    }\n\n    // If we've made it to this point, it means the points are diagonally colinear and now we need to figure out the distance between them.\n    // AKA how many steps must we traverse to get from gridCoordA to gridCoordB?\n\n    // This is a bit of a dirty hack, but basically all diagonally-adjacent grid points have a constant cartesian distance between them which is about 1.11803398875\n    // So we just take the total cartesian distance and divide it by this constant value and then round it to the nearest integer.\n    // It's dirty because the larger the distance, the larger the error will be.\n    // But for our use case in this EmojiScope project I highly doubt we will ever come across this problem, so I'm gonna just go for it because time is of the essence.\n\n    return Math.round(\n      CartesianUtil.getDistance(cartPointA, cartPointB) / diagonallyAdjacentNodeDistance,\n    );\n\n    // There is absolutely a much more correct way to rewrite this entire function to be completely robust to all inputs, and perhaps someday it may be worth exploring.\n  }\n\n  /**\n   * @description Gets distance between two coordinates, and always returns a number even if they are non-colinear.  Please, read on...\n   * In cases where we are 100% sure that getDistanceBetween will always return a number, here is a convenience function that returns 0 instead of undefined so the return type is always number.\n   * Only use it if you're 100% confident that using getDistanceBetween won't return undefined.\n   * ...because it WILL HIDE LOGIC BUGS\\\n   *\n   * Please, please, please... use it wisely.\n   * @param {Index2D} gridCoordA\n   * @param {Inndex2D} gridCoordB\n   *\n   * @return {number} a number representing the distance between gridCoordA and gridCoordB, or potentially just 0 if something went wrong\n   */\n  function unreliableDistanceBetween(gridCoordA: Index2D, gridCoordB: Index2D): number {\n    return getDistanceBetween(gridCoordA, gridCoordB) ?? 0;\n  }\n\n  /**\n   * @name areCoordsColinear\n   * @description - Tests to see if two grid points are colinear, that is, they exist on the same line along a valid GridDirection\n   * It's mainly just a cut-down version of the above function getGridDistanceBetween where instead of returning a distance we just want to know if two points are colinear\n   *\n   * @param {Index2D} coordA - Coordinate A\n   * @param {Index2D} coordB - Coordinate B\n   * @return {boolean} - Whether or not the coords are colinear\n   */\n  function areCoordsColinear(coordA: Index2D, coordB: Index2D): boolean {\n    // Let's cover the simplest case first.\n    if (Math.abs(coordA.y - coordB.y) < EPSILON) {\n      // coords with same y-value are always colinear\n      return true;\n    }\n\n    const cartPointA: Point2D = CartesianUtil.gridToCart(coordA);\n    const cartPointB: Point2D = CartesianUtil.gridToCart(coordB);\n\n    // Since we already covered the case where the points have the same y-value, we are just looking to see if the slope between the points is within EPSILON of 2.0\n    // If so, then we can consider the points to be colinear and calculate their distance\n    const { x: dx, y: dy } = subtract2D(cartPointA, cartPointB);\n\n    if (Math.abs(dx) < EPSILON) {\n      // if dx is close enough to 0 so the coords aren't colinear because ShiftedGrid does not allow adjacent nodes to be directly above or below each other\n      return false;\n    }\n\n    if (Math.abs(2.0 - Math.abs(dy / dx)) > EPSILON) {\n      // Slope is not close enough to 2 to be colinear\n      return false;\n    }\n\n    // If we've made it here, we can safely assume the coords are colinear\n    return true;\n  }\n\n  /**\n   * @name isCoordBetween\n   * @param {Index2D} p - The coordinate to test and find out if it's between the rectangle formed by coords a and b\n   * @param {Index2D} a - Coord A\n   * @param {Index2D} b - Coord B\n   * @return {boolean} - Whether or not p is within the rectangle formed by coords a and b\n   */\n  function isCoordBetween(p: Index2D, a: Index2D, b: Index2D): boolean {\n    const xMin = Math.min(a.x, b.x);\n    const xMax = Math.max(a.x, b.x);\n    const yMin = Math.min(a.y, b.y);\n    const yMax = Math.max(a.y, b.y);\n\n    return p.x >= xMin && p.x <= xMax && p.y >= yMin && p.y <= yMax;\n  }\n\n  /**\n   * @name indexToCoord\n   * @description A magical O(1) function that returns an Index2D given a single numeric nodeIndex\n   *\n   * @param {number} nodeIndex - The index of the node whose coord we need\n   *\n   * @return {Index2D} - The grid coord representing the node at the given index\n   */\n  const indexToCoord = (function () {\n    // This is an array of directions to traverse from one RingCorner to the next one\n    const traversalDirections: GridDirection[] = [\n      GridDirection.NXPY, // from p0 -> p1\n      GridDirection.NX, // from p1 -> p2\n      GridDirection.NXNY, // from p2 -> p3\n      GridDirection.PXNY, // from p3 -> p4\n      GridDirection.PX, // from p4 -> p5\n      GridDirection.PXPY, // from p4 -> p0 of next ring\n      // ^ this is here for completeness, and to prevent traversalDirection[5] from being undefined\n    ];\n\n    // This is the actual function :)\n    return function (nodeIndex: number): Index2D {\n      // get the index of the ring that contains the node at nodeIndex\n      const ringIndex = getRingIndex(nodeIndex);\n\n      // get the sub-index of the node in its ring\n      const nodeSubIndex = nodeIndex - getFirstNodeIndexInRing(ringIndex);\n\n      // get the corner point ID of this ring closest to nodeSubIndex, but whose subIndex within the ring is less than nodeSubIndex.\n      const leadingCorner = getLeadingRingCorner(ringIndex, nodeSubIndex);\n\n      // get the subIndex of the RingCorner we just calculated\n      const cornerSubIndex = getRingCornerSubIndex(ringIndex, leadingCorner);\n\n      // get the Index2D position of the RingCorner\n      const cornerPosition = getRingCornerCoord(ringIndex, leadingCorner);\n\n      // calculate the distance we need to traverse from cornerSubIndex to nodeSubIndex\n      const traversalDistance = nodeSubIndex - cornerSubIndex;\n\n      // now we just traverse from cornerPosition by traversalDistance in the correct direction!\n      return traverse(cornerPosition, traversalDirections[leadingCorner], traversalDistance);\n    };\n  })();\n\n  // Function is defined in anonymous scope because of specialized constants we will need during its execution\n  const coordToIndex = (function () {\n    const cornerRay5Origin: Index2D = { x: 1, y: 0 };\n\n    /**\n     * @name coordToIndex\n     * @description Another magical O(1) function which takes in a grid coordinate (Index2D) and outputs a 1D index following the spiral pattern.\n     * @param {Index2D} targetCoord - The grid coord whose index we want\n     * @return {number} - The index of this targetCoord, following i spiral-shape.\n     */\n    return function (targetCoord: Index2D): number {\n      // We need to find which GridQuadrant the targetCoord is in\n      const targetQuadrant = getGridQuadrant(targetCoord);\n\n      // We also need to find the intersector direction for this quadrant\n      const intersectorDirection = IntersectorDirectionForQuadrant[targetQuadrant];\n\n      // Let's create a GridRay that starts at targetCoord and goes in the direction of intersectorDirection\n      const targetIntersectorRay = createGridRay(targetCoord, intersectorDirection);\n\n      // We need to get the direction of the leading corner for this quadrant\n      const leadingCornerDirection = CornerDirectionForQuadrant[targetQuadrant];\n\n      // Define our cornerRay startCoord. Ray 5 has a special startCoord.\n      const cornerRayStartCoord =\n        targetQuadrant === GridQuadrant.PXNY ? cornerRay5Origin : origin2D;\n\n      // Define a GridRay that starts at the cornerRayStartCoord and goes in the direction of the leading corner\n      const cornerRay = createGridRay(cornerRayStartCoord, leadingCornerDirection);\n\n      // Now we need to find the intersection point between targetIntersectorRay and originToCornerRay\n      const intersectionPoint = getLineIntersection(\n        targetIntersectorRay.asCartLine(),\n        cornerRay.asCartLine(),\n      );\n\n      if (intersectionPoint === undefined) {\n        // this should never happen, if it does then something is extremely wrong\n        return 0;\n      }\n\n      // Get intersectionPoint as grid coordinate\n      const leadingRingCornerCoord = CartesianUtil.cartToGrid(intersectionPoint);\n\n      // leadingRingConerCoord should always be on a ring corner.\n      // TODO: For direction PXNY we need to add 1 to the x-coordinate\n      // Get ring index of this targetCoord using the distance between center and leadingRingConerCoord\n      const targetRingIndex = unreliableDistanceBetween(\n        cornerRayStartCoord,\n        leadingRingCornerCoord,\n      );\n\n      // Get the RingCorner that leadingRingConerCoord represents\n      const leadingRingCorner = getRingCornerOfCornerCoord(leadingRingCornerCoord);\n\n      // Get the index of leadingRingCorner\n      const leadingRingCornerIndex = getRingCornerIndex(targetRingIndex, leadingRingCorner);\n\n      // Get distance between targetCoord and leadingRingCornerCoord\n      const distToLeadingRingCorner = unreliableDistanceBetween(\n        targetCoord,\n        leadingRingCornerCoord,\n      );\n\n      // The result index should just be leadingRingCornerIndex + distToLeadingRingCorner!\n      return leadingRingCornerIndex + distToLeadingRingCorner;\n    };\n  })();\n\n  // Return all the functions for GridUtil here\n  return {\n    createShiftedGrid,\n    traverse,\n    getDistanceBetween,\n    unreliableDistanceBetween,\n    areCoordsColinear,\n    isCoordBetween,\n    indexToCoord,\n    coordToIndex,\n  };\n})(); // End of anonymous function returning GridUtil\n","export * from './ShiftedGrid';\n"],"sourceRoot":""}